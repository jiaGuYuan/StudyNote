机器学习笔记:
    
监督学习:
    训练数据集的每条记录中包含了实际结果;算法根据该实际结果获得反馈.

    常见问题域:
        回归(regression)--对应于连续的值域, 分类(Classification)--对应离散的值域,
        多元线性回归可通过特征缩放来使得对代价函数进行递归下降时更快的到达局部最小值.
        --具体操作的可将特征范围控制在[-1, 1],可以有偏差,但偏差不能过大. 如[-0.00001, 0.000002],[-100, 100]都不太好.
        
        回归:
            线性回归,梯度下降(),BFGS,L-BFGS
            
            一对多的分类问题可以分解为多个一对一问题.
            
        分类:
            logistic回归,
            
            
        神经网络:
            --解决非线性分类问题

            正向传播:
                ...
            反向传播:
                使用梯度检验可以解决反向传播及类似算法的一些Bug:
                梯度检验: 即使用参数theta在某个值附近的斜率来对反向传播得到的梯度进行比较,
                           如果在误差范围内两者相等;则认为反向传播算法的实现是正确的．
                    一旦通过梯度检验代码验证了反向传播算法的正确性后,在正常使用的代码中去掉梯度检验代码，因为梯度检验代码运行很慢(比反向传播算法要慢很多)．
                使用随机初始化的思想对参数进行初始化．

     不均衡数据的评估:
        查准率 & 召回率: (Precision & Recall)
            查准率表示:预测为True的结果中实际为True的结果占的比例
                查准率 = (预测为True & 实际为True)/(预测为True) = (预测为True & 实际为True)/((预测为True & 实际为True)+(预测为True & 实际为False))
                查准率越大越好
            召回率表示:实际为True的结果中预测为True的结果占的比例
                召回率 = (实际为True & 预测为True)/(实际为True) = (实际为True & 预测为True)/((实际为True & 预测为True)+(实际为True & 预测为False))
                查准率越大越好
        
        好的算法可以保证 查准率 & 召回率 的相对平衡.
    
        查准率&召回率的权衡:
            F = 2*((P*R)/(P+R))  值越大越好. P:查准率, R:召回率
    
    支持向量机(SVM):
        学习复杂的非线性方程.
    
无监督学习:
    训练数据集中不包含结果,算法自动从中识别结构.
    
    常见问题域:
        聚类算法, K-邻近算法, 异常检测.
        
        
    异常检测:
        假设各个特征是符合高斯分布(正太分布)的 ---- X ~ N(μ, σ^2)
        p(x; μ, σ^2) = p(x1; μ1, σ1^2)p(x2; μ2, σ2^2)...p(xm; μm, σm^2)
        if p(x_test)<ε :
            anomaly(异常)
        else:
            normal(正常)

        异常检测中的样本可以是带有标签的,但是样本是严重倾斜的(如10020个飞机引擎样本中只有20个异常样本).
        这种情况下将样本集划分为: 训练集:(正常6000) + 交叉验证集(正常2000,异常10) + 测试集(正常2000,异常10)
        在使用训练集进行模型训练时使用无监督方式进行训练．
        在交叉验证集时使用 查准率&召回率 对异常检测模型进行评估．

        在正样本和负样本规模相近(或有足够的正样本和负样本)时,可将异常检测转换成监督学习来处理．
        
        高斯分布 & 多元高斯分布

        
协同过滤算法: Collaborative Filtering
    基于用户的协同过滤算法:
        简言之: 基于用户的协同过滤算法就是按相似用户进行推荐 -- 与他口味相似者购买了哪些物品,则他也可能购买这些物品.
        找的是用户的特征.
        例如:已知用户对物品的评价{#userX:{#物品X:评分X,...}, ...} --> 计算用户间的相似程度 --> 根据与指定用户相似度高的用户集来对他进行推荐物品.
        
        
    基于物品的协同过滤算法:
        简言之: 基于物品的协同过滤算法就是 -- 他购买过物品XXX,他可能会购买物品YYY.
        找的是物品的特征.
        例如:已知用户对物品的评价{#物品X:{#userX:评分X,...}, ...} --> 计算物品间的相似程度 --> 从用户的购买历史中获取其喜欢购买的物品种类,为用户推荐类似物品.

        
上限分析:
    上限分析: 逐一的将各个步骤中的输出,并得到一个整体输出,看哪一个步骤对整体性能影响较大.
    如:某系统有如下5个步骤: A --> B --> C --> D --> E
    该系统的预测准确率为72%, 使用上限分析判断对哪个模块进行优化比较有用
    状态                                               系统的预测准确率
    不人为干预时                                        72%
    人为使A正确率达到100%                               89%
    再人为使B正确率达到100%                             90%
    再人为使C正确率达到100%                             93%
    再人为使D正确率达到100%                             95%
    再人为使E正确率达到100%                             100%
    
    可以发现优化A模块,最大可使系统准确率提升17%.
    但即使B模块完全准确,也只能使系统准确率提升1%.
    因为通过该上限分析可以避免我们在B模块上浪费时间.
                
    上限分析可以确定将时间花在工作流中的哪些模块上,避免花费大量时间在一个对整体系统性能提升不大的模块上.
        
        
        
        
欠拟合,
    --高偏差
        验证数据集误差大 && 训练数据集误差大
过拟合
    --高方差
        验证数据集误差大 && 训练数据集误差小

    避免过拟合的方法:
        1. 减少特征变量
        2. 正则化
            --通过加入惩罚来控制参数theta取比较小的值

常用词:
    Hypothesis 假设



计算模型参数的方法:
    1.构造一个[总体]误差函数(描述预测值与实际值的差距)--代价函数--代价函数描述了优化目标.
    2.可通过计算误差函数的极值来获取模型的参数.
        --不是直接计算极值,而是通过对训练数据进行不断的迭代,最后获得误差极值--是逐步逼近的过程.
            --如:使用梯度下降算法
    ---最终在训练集上得到使得代价函数取最小值的一组参数.
    --几个问题:
       1. 代价函数要如何选取 
       2. 如何更快的使得代价函数在训练数据上得到收敛结果.
        
    --直接计算参数的方法: 正规方程 -- pinv(X' * X) * X' * y
      --正规方程不需要梯度下降不断逼近极值,来获取参数值;而是直接计算出参数值.
        但是它不适用于特征变量过多的情况(因为计算逆是很费时的).  
        --建议:在特征数在10000以下时可以使用正规方程来计算参数
        
--在模型函数中,样本是变量.
--在代价函数中,参数是变量.

    
 
XXX算法:
    算法原理:
    算法实现:
    算法应用:
    好的实践:
    
    
    
Octave:
    基本:
        % -- 注释
        ~= --不等于
        
        PS1('XXX')  --修改命令行提示符为XXX
            --例: PS1('>> ')
            
        var = 23  --给变量赋值
        var = 23; --给变量赋值,但';'号使用结果不在屏幕上输出
        
        m = [1 2; 3 4; 5 6] --生成一个3x3的矩阵(';'号表示换行)
        
        start:step:end --生成一个[start, end]的序列,步长为 step
            --例: v = 1:1:10 
            
        ones(N, M) --生成一个N*M的1矩阵(各元素均为1)
            --例: ones(2, 3)
            
        zeros(N, M) --生成一个N*M的0矩阵(各元素均为0)
            --例: zeros(2, 3)
            
        rand(N, M) --生成一个N*M的随机矩阵(各元素在[0,1]中随机取值)
            --例: rand(2, 3)
            
        randn(N, M) --生成一个N*M的服从标准高斯分布的矩阵
            --例: randn(2, 3)
            
        eye(N) --生成一个N*N的单位阵(对角元素均为1)
            --例: eye(2)
            
        help cmd -- 查看帮助
            --例: help eye
        
        linspace(N, M, NUM); --将[N, M]分为NUM个.
        logspace(N, M, NUM); --将[10^N, 10^M]分为NUM个.

        A = [1 2; 3 4; 5 6]
        size(A) -- 返回A矩阵的大小 -- 3 2
        size(A, 1) -- 返回A矩阵第一个维度(行)的大小 -- 3
        size(A, 2) -- 返回A矩阵第二个维度(列)的大小 -- 2
        
        length(A) -- 返回矩阵A中较大的那个维度的值 -- 3
            --length()一般作用于向量
        
        加载文件:
            load fileName
            load('fileName')
        保存到文件:
            save outFileName varName -binary %将变量varName中的内容以二进制的方式保存到文件outFileName
            save outFileName varName -ascii  %将变量varName中的内容以文本的方式保存到文件outFileName(输出文件中不包含Octave文件头信息; 只包含纯数据列)
            save outFileName varName -text  %将变量varName中的内容以文本的方式保存到文件outFileName(输出文件中包含Octave文件头信息)
            
        who -- 显示Octave环境中的所有变量
        whos -- 与who类型,但显示信息更详细
        clear -- 清除Octave环境中的所有变量
        clear varName -- 清除Octave环境中的varName变量
    
    使用索引访问矩阵(或向量): -- 引用从1开始!!!
        行向量: (逗号)
            v = [1, 2, 3, 4]
            或
            v = [1 2 3 4]
        列向量: (分号)
            v = [1; 2; 3; 4]
        
        矩阵:  (注意:逗号与分号的使用)
            A = [1 2 3 4; 5 6 7 8; 9 10 11 12]
            或
            A = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12]
            或
            A = [[1, 2, 3, 4]; [5, 6, 7, 8]; [9, 10, 11, 12]]
        
        A(i, j) -- 第i行,第j列元素
            --A(2, 2) == 6
        A(i, :) -- 第i行的所有元素 --结果为一个行向量
            --A(1, :) == 1 2 3 4
        A(:, j) -- 第j列的所有元素 --结果为一个列向量
            --A(:, 1) == 1
                         5
                         9
        A(i, start:step:end) -- 第i行的第[start, end]个元素,步长为step(默认为1)
            --A(1, 1:3) == 1 2 3  --第1行的第[1, 3]个元素,步长为1
            --A(1, 1:2:4) == 1 3  --第1行的第[1, 4]个元素,步长为2
            --A(1, 1:1:4) == 1 2 3 4 --第1行的第[1, 4]个元素,步长为1
        A(i, [start:step:end]) -- 等价于 A(i, start:step:end)
        
        A(start:step:end, j) -- 第j列的第[start, end]个元素,步长为step(默认为1)
        A([start:step:end], j) -- 等价于 A(start:step:end, j)
        
        A([start:step:end], :) -- 取A的[start:step:end]行
        A(:, [start:step:end]) -- 取A的[start:step:end]列
        
        A(:) -- 将A的所有元素转换成一个列向量.(按列拼接)
        
        
        修改A的元素:
            A(i, j) = NUM  %修改单个元素
                --A(1, 1) = 0
            A(i, :) = 行向量   %修改一行
                --A(1, :) = [0 -1 -2 -3]
            A(:, j) = 列向量   %修改一列
                --A(:, 1) = [100; 500; 900]
        追加:
            追加行:
                A = [A; 行向量]
                    --A = [A; [100, 101, 102, 103]]
            追加列:
                A = [A, 列向量]
                    --A = [A, [-100; -101; -102]]
        矩阵合并:
            A = [1 2; 3 4]
            B = [5 6; 7 8]
            横向合并:
                C = [A, B]   %等价于C = [A B]
                 -- C == [1 2 5 6; 3 4 7 8]
            纵向合并:
                C = [A; B]
                 -- C == [1 2; 3 4; 5 6; 7 8]
                 
        矩阵运算:
            A * B  %矩阵乘
            A .* B %对应元素相乘
            A .^ 2 %各元素平方
            1 ./ A %各元素取倒数
            log(A) %各元素取对数
            exp(A) %对各元素x求 e^x
            abs(A) %各元素求绝对值
            v + ones(length(v), 1) %对向量v的每个元素加1
            v + 1 %对向量v的每个元素加1
            
            A'     %A的转置
            
            val_max = max(v)  %返回向量v中的最大值 
            [val_max, index] = max(v) %返回向量v中的最大值和取最大值时的索引
            
            C = max(A, B) %矩阵C中的各元素由矩阵A和B中对应位置元素的较大值决定
            rowV_colmax = max(A, [], 1) %返回一个行向量,各元素对应矩阵A中各列的最大值
            rowV_colmax = max(A)        %返回一个行向量,各元素对应矩阵A中各列的最大值
            colV_rowmax = max(A, [], 2) %返回一个列向量,各元素对应矩阵A中各行的最大值
            max(max(A)) %返回矩阵A所有元素中的最大值
            max(A(:))    %返回矩阵A所有元素中的最大值
            
            A < 3 %返回一个矩阵,若A中该位置的元素小于3则取1,否则取0
            
            find(v < 3) %返回向量v中小于3的元素的索引
            [r c] = find(A < 3) % r c中分别返回矩阵A中小于3的元素的行列索引
            x = find(A < 3)  % 将A按列转换成一个向量,返回向量中小于3的元素的索引
            
            sum(v) %对向量v中的所有元素求和
            sum(A) %返回一个向量,向量元素为对矩阵A各列的求和
            sum(sum(A)) %返回矩阵A所有元素的和
            
            prod(v) %对向量v中的所有元素求积
            prod(A) %返回一个向量,向量元素为对矩阵A各列的求积
            prod(prod(A)) %返回矩阵A所有元素的积
            floor(a) %对a向下取整
            ceil(a)  %对a向上取整
            
            magic(N)  %返回一个魔幻方阵,其任意行,列,对角线之和均相等
        
    控制:
        
        a = 2
        if a;
            disp('a is true');
        end;
        
        a = 6
        if a == 1;
            disp('1');
        elseif a == 2;
            disp('2');
        else;
            disp('Other');
        end;
        
        
        v = zeros(10, 1);
        
        for i=1:length(v);
            v(i) = 2 ^i;
        end;

    
        i=1;
        while i <= 5;
            v(i) = 100;
            i = i + 1;
        end;

        break,continue用法也C一致
    
    函数:
        mySquareAndCubeThisNumber.m文件:
            %定义一个名为mySquareAndCubeThisNumber的函数
            %Octave可以同时返回多个值
            function [y1, y2] = mySquareAndCubeThisNumber(x); 
                y1 = x ^ 2;  %函数体
                y2 = x ^ 3;
            end;
            
            --注意:保持文件名与函数名相同
    
    添加Octave搜索路径:
        addpath('D:/gjy')
    
    绘图:
        w = E + sqrt(Variance) * randn(N, M) --生成一个N*M的服从期望为E,方差为Variance的高斯分布的矩阵
        --例: w = -6 + sqrt(10) * (randn(1, 50000));
        hist(w, 500) --将w绘制成直方图(500表示绘制直方的数目)
    
        plot:
            t = [0: 0.0001: 1];
            y1 = sin(2*pi*4*t);
            y2 = cos(2*pi*4*t);
            
            plot(t, y1)
            hold on; %为了在同一张画布上绘制多条曲线
            plot(t, y2, 'r-.')
            xlabel('time')
            ylabel('value')
            legend('sin', 'cos')  %设置曲线标签,参数要与绘制曲线的顺序一致
            title('my plot')
            print -dpng 'myPlot.png' %保存到文件
    
            2:
            figure(1); plot(t, y1)
            figure(2); plot(t, y2)
            
            3:
            %将一个图片分成1x2的格子; 在1格式绘制y1的图像,在2格子绘制y2的图像
            subplot(1, 2, 1); plot(t, y1)  
            subplot(1, 2, 2); plot(t, y2)
            
            4:
            axis([x_left x_rigth y_bottom y_top]) %设置x轴和y轴的范围
            

    将多个矩阵组合成一个列向量 &　再将其还原为原始结构矩阵:
        例: A ∈ R(M x N); B ∈ R(P x Q);  C ∈ R(l x L)
            将矩阵A B C组合成一个列向量: DVec = [A(:); B(:); C(:)]
            将列向量还原为原始结构矩阵: 
                A1 = reshape(DVec(1: M*N), M, N)
                B1 = reshape(DVec(M*N+1: M*N+P*Q), P, Q)
                C1 = reshape(DVec(M*N+P*Q+1: M*N+P*Q+L), 1, L)
    
    
    
    
学习网址:
    XGBoost:
        https://github.com/dmlc/xgboost/tree/master/demo/guide-python
        
    
    
    
    
    
    
    
    
    
    