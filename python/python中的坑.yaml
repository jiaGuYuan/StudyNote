多重列表初始化中的坑(可变类型&不可变类型):
    注意: 使用乘法扩充的列表,进行针对元素的是浅复制(类似与C++的引用)
    当列表元素为不可变类型时,使用乘法扩充列表没有问题:
        x1, x2 = 0, 1
        list0 = [x1, x2]
        # 对list0的元素(数值类型)进行2次浅copy得到list1
        list1 = list0 * 2  # [x1, x2, x1, x2]
        # id(x1) == id(list1[0]) == id(list1[2]) --可以证明是元素的浅copy
        # id(x2) == id(list1[1]) == id(list1[3])
        list1[2] = 10 # 因为列表元素为不可变类型,所以赋值后原引用不受影响
        # id(x1) == id(list1[0]) != id(list1[2])
    
    当列表元素为可变类型时,使用乘法扩充列表容易出问题:
        当列表元素为可变类型时(如元素类型也为列表),由于是基于元素进行浅copy,
        因此修改其中一个,所有引用均被修改
        list3 = [0, 1]
        list4 = [2, 3]
        
        # 列表元素为可变类型(列表)
        list_2d = [list3, list4]  #[[], []]
        # 对list_2d_new的元素(数值类型)进行2次浅copy得到list_2d_new
        list_2d_new = list_2d*2 # [list3, list4, list3, list4]
        # 其中list_2d_new[0], list_2d_new[2]均是list3的引用,它们的id相同,修改其中任何一个,都会影响其它几个.
        #     list_2d_new[1], list_2d_new[3]均是list4的引用,它们的id相同,修改其中任何一个,都会影响其它几个.
        list_2d_new[0][0] = 9 # list3[0]将会被修改,list_2d_new[2][0]也将会被修改--实际上它们对应同一份数据
        
    常见错误用法, 二维列表(数组)初始化:
        matrix = [[0]*2]*3
        matrix # [[0, 0], [0, 0], [0, 0]]
        matrix[0][0] = 1 # !!!这里改变的是matrix所有行的第0列!!!
        matrix # [[1, 0], [1, 0], [1, 0]]
    
    正确的初始化方式:
        matrix = [[0]*2 for i in range(3)]
        matrix[0][0] = 1 # 这里改变的只是matrix第0行的第0列
        
        
        
    lst*N是将lst的元素复制N份(引用复制); 
    当lst是list of int时, lst的元素是int类型-是不可变对象, 所以*N时是产生了新空间的, 此时操作不存在共享的问题. 
    当lst是list of list时,lst的元素是list对象-是可变对象, 所以*N时直接使用的是lst元素的引用--存在空间共享问题.