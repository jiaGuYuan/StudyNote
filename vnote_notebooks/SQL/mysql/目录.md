# 目录

* 01 | 基础架构：一条SQL查询语句是如何执行的？

#### 索引相关
* 04 | 深入浅出索引（上）
* 05 | 深入浅出索引（下）
* 09 | 普通索引和唯一索引，应该怎么选择？
* 10 | MySQL为什么有时候会选错索引？
* 11 | 怎么给字符串字段加索引？
* 15 | 答疑文章（一）：日志和索引相关问题
* 16 | “order by”是怎么工作的？
* 18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？
* 39 | 自增主键为什么不是连续的？

#### 事务相关
* 03 | 事务隔离：为什么你改了我还看不见？
* 08 | 事务到底是隔离的还是不隔离的？
* 20 | 幻读是什么，幻读有什么问题？

#### 锁相关
* 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
* 07 | 行锁功过：怎么减少行锁对性能的影响？
* 19 | 为什么我只查一行的语句，也执行这么慢？
* 20 | 幻读是什么，幻读有什么问题？
* 21 | 为什么我只改一行的语句，锁这么多？
* 30 | 答疑文章（二）：用动态的观点看加锁
* 40 | insert语句的锁为什么这么多？

#### 日志与主备相关
* 02 | 日志系统：一条SQL更新语句是如何执行的？
* 12 | 为什么我的MySQL会“抖”一下？
* 23 | MySQL是怎么保证数据不丢的？
* 24 | MySQL是怎么保证主备一致的？
* 25 | MySQL是怎么保证高可用的？
* 26 | 备库为什么会延迟好几个小时？
* 27 | 主库出问题了，从库怎么办？
* 28 | 读写分离有哪些坑？
* 29 | 如何判断一个数据库是不是出问题了？
* 31 | 误删数据后除了跑路，还能怎么办？

#### 临时表相关
* 17 | 如何正确地显示随机消息？
* 34 | 到底可不可以使用join？
* 35 | join语句怎么优化？
* 36 | 为什么临时表可以重名？
* 37 | 什么时候会使用内部临时表？
* 43 | 要不要使用分区表？

#### 实用性归类
* 14 | count(*)这么慢，我该怎么办？
* 32 | 为什么还有kill不掉的语句？
* 33 | 我查这么多数据，会不会把数据库内存打爆？
* 41 | 怎么最快地复制一张表？
* 44 | 答疑文章（三）：说一说这些好问题
* 45 | 自增id用完怎么办？
* 38 | 都说InnoDB好，那还要不要使用Memory引擎？

#### 
* 13 | 为什么表数据删掉一半，表文件大小不变？
* 22 | MySQL有哪些“饮鸩止渴”提高性能的方法？