边界:
    ^: 起始
    $: 结束
    \b: 单词边界(零宽) reg("xx The xx", "\bThe\b")-->"The"
    \B: 非单词边界(零宽) reg("xx The xx", "\Bh\B")-->"h"


贪婪&非贪婪:
    贪婪匹配量词(匹配优先量词):
        {m,n}, {m,}, ?, * 和+ 
    非贪婪模式的量词(忽略优先量词)
        {m,n}?, {m,}?, ??, *? 和+? 

    例: 原始串:"aa<div>test1</div>bb<div>test2</div>cc"
        reg: <div>.*</div> --贪婪--> "<div>test1</div>bb<div>test2</div>"
        reg: <div>.*?</div> --非贪婪--> "<div>test1</div>"

分组:
    分组中捕获的数据可用于后向引用, 引用方式\i(其中\0表示整个匹配) --分组编号的顺序根据左括号"("的位置来计算.
    捕获组:
        (exp)  --匹配exp,并将分组匹配的文本保存到按索引命名的组里
    命名捕获组:
        (?<name>exp) 或 (?"name"exp) --匹配exp,并将分组匹配的文本保存到名为name的组里
    非捕获组:
        (?:exp) -- 匹配exp,但不捕获(不保存匹配内容到组)
    
    
    零宽断言:
        --用于查找某些内容(但不包括这些内容)之前或之后的东西.
        --注意: 区分正则中的＂匹配字符＂ 与 "匹配位置"
        零宽正预测先行断言: 
            (?=exp) --匹配exp前面的位置(定义目标字符串结束位置要求).(用法"MatchEXP(?=exp)")
            Eg: 原始串 "I"m singing while you"re dancing"
                reg: 非零宽 "\b\w+(?:ing\b)" ----> "singing"
                       零宽 "\b\w+(?=ing\b)" ---> "sing"

        零宽正回顾后发断言:
            (?<=exp) --匹配exp后面的位置(定义目标字符串起始位置要求).(用法"(?<=exp)MatchEXP")
            Eg: 原始串 "I"m singing while you"re dancing"
                reg: 非零宽 "(?:\byo)[a-z"]+\b" ----> "you"re"
                       零宽 "(?<=\byo)[a-z"]+\b" ---> "u"re"
                
        零宽度负预测先行断言:
            (?!exp)  --匹配后面跟的不是exp的位置(定义目标字符串结束位置要求).(用法"MatchEXP(?!exp)")
            Eg: 原始串 "abZW8863abx"
            reg: 非零宽 "ab(?:[^A-Z])" ----> "abx"
                   零宽 "ab(?![A-Z])"  ---> "ab" 注:(?![A-Z])匹配到字符"x"的位置(但不计入结果),所以输出的是"ab"
            
        零宽度负回顾后发断言:
            (?<!exp) --匹配前面不是exp的位置(定义目标字符串起始位置要求).(用法"(?<!exp)MatchEXP")
            原始串: "ZW8863ab"
            reg: 非零宽 "(?:[^A-Z])8" ----> "88"
                   零宽 "(?<![A-Z])8" --> "8" 注：(?<![A-Z])匹配到第3个字符的位置(但不计入结果),输出的是第4个字符"8"
        总结:
            零宽  --  只产生匹配位置,匹配位置不记入匹配结果
            正　　-- 正匹配
            负　　-- 不匹配
            先行　-- (目标先行;目标在前)产生的是匹配目标的结束位置
            后发　-- (目标后发;目标在后)产生的是匹配目标的开始位置
    
排除:
    [^charset]排除指定的字符集合
        "\b[^aeiou "]+\b" -- 匹配不包含元音的单词
 

模式修饰符: 
    i: 不区分大小写  (?i)
        原始串: "I"m singiNg while you"re dancing"
            reg: "\b\w+(?i)ing" --> "singiNg"
    s: 默认"."匹配除换行符"\n"之外的任何单字符; 加上s之后"."也可正常匹配"\n"
        原始串: "helloworld\r\nhelloGjy"
            reg:　".*"  ---> "helloworld"
                  "(?s).*" --> "helloworld\r\nhelloGjy"
 
身份证编码规则:
    431225 19940302 481X
    前6位: 地址码:行政区划代码,1-2位省,自治区,直辖市代码; 3-4位地级市; 5-6位县
    7-14:　出生年月日
    15-17: 地址码中的人员编码(奇数-男性, 偶数-女性)
    最后一位: 检验码
    
    
IP匹配模式:  ^(?:2[0-4]\d|25[0-5]|1?\d\d?)(?:\.(?:2[0-4]\d|25[0-5]|1?\d\d?)){3}$

/*
 ?:pattern   表示匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配
 ?  匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。  
    当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的

    192.168.1.90  分成两部分:  第一部分-- (数字) 
                               第二部分-- (.数字){3}

    其中数字满足如下条件:
    1位: \d
    2位: \d\d
    3位: 1\d\d| 2[0-4]\d |25[0-5]
        其中1位,2位的情况可以合并为 \d\d?
        进而1位,2位以及1\d\d的情况可以合并为 1?\d\d?
    所以数字部分的模式为 (?:2[0-4]\d|25[0-5]|1?\d\d?)
    所以整个IP匹配的模式为:
    ^(?:2[0-4]\d|25[0-5]|1?\d\d?)(?:\.(?:2[0-4]\d|25[0-5]|1?\d\d?)){3}$
 */